import { readCache, writeCache } from '../../files/cache-file.js';
import { randomUUID } from 'crypto';
import { KBEntry, GainKnowledgeArgs, QueryKnowledgeArgs, QueryResult } from './types.js';
import {
  GenerateContentFunction,
  ModelType,
  FunctionDef,
  PromptItem,
  FunctionCall,
} from '../../ai-service/common-types.js';

const KNOWLEDGE_CACHE_KEY = 'container-task-knowledge-v1';

// Function definition for providing context to the LLM.
export const knowledgeContextDef: FunctionDef = {
  name: 'provideKnowledgeContext',
  description: 'Provides the user query and knowledge base corpus for ranking.',
  parameters: {
    type: 'object',
    properties: {},
    required: [],
  },
};

// Function definition for the LLM to call to return ranked results.
const respondKnowledgeQueryDef: FunctionDef = {
  name: 'respondKnowledgeQuery',
  description: 'Returns a result of the knowledge query.',
  parameters: {
    type: 'object',
    properties: {
      synthesizedResponse: {
        type: 'string',
        description: 'The synthesized response generated by the LLM based on the knowledge query.',
      },
      sourceEntries: {
        type: 'array',
        description: 'An array of knowledge base entries that are very relevant to the query.',
        maxItems: 3,
        items: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'The unique identifier of the knowledge base entry.',
            },
          },
          required: ['id'],
        },
      },
    },
    required: ['synthesizedResponse', 'sourceEntries'],
  },
};

export async function getKnowledgeBase(): Promise<KBEntry[]> {
  const entries = await readCache<KBEntry[]>(KNOWLEDGE_CACHE_KEY, []);
  return entries;
}

async function writeKnowledgeBase(entries: KBEntry[]): Promise<void> {
  await writeCache(KNOWLEDGE_CACHE_KEY, entries);
}

export async function appendKnowledge(entryData: GainKnowledgeArgs): Promise<KBEntry> {
  const knowledgeBase = await getKnowledgeBase();
  const newEntry: KBEntry = {
    id: randomUUID(),
    createdAt: new Date().toISOString(),
    ...entryData,
  };
  knowledgeBase.push(newEntry);
  await writeKnowledgeBase(knowledgeBase);
  return newEntry;
}

export async function queryKnowledge(
  args: QueryKnowledgeArgs,
  generateContentFn: GenerateContentFunction,
): Promise<QueryResult> {
  const { query } = args;
  const knowledgeBase = await getKnowledgeBase();

  if (knowledgeBase.length === 0) {
    return {};
  }

  const corpus = knowledgeBase.map((entry) => ({
    id: entry.id,
    prompt: entry.prompt,
    answer: entry.answer,
  }));

  const systemPrompt = `
    You are an AI assistant that ranks knowledge base entries based on relevance to a user query.
    You will be given the context (query and corpus) as a function response to 'respondKnowledgeQuery'.
    Your task is to analyze this context and call the 'respondKnowledgeQuery' function with the results.
  `;

  const prompt: PromptItem[] = [
    {
      type: 'systemPrompt',
      systemPrompt,
    },
    {
      type: 'user',
      text: 'Hello!',
    },
    {
      type: 'assistant',
      text: 'Please provide me with context: corpus, query',
      functionCalls: [
        {
          name: 'provideKnowledgeContext',
        },
      ],
    },
    {
      type: 'user',
      text: `Query: ${query}`,
      functionResponses: [
        {
          name: 'provideKnowledgeContext',
          content: JSON.stringify({ query, corpus }),
        },
      ],
    },
  ];

  const response = await generateContentFn(
    prompt,
    {
      modelType: ModelType.LITE,
      temperature: 0.1,
      functionDefs: [knowledgeContextDef, respondKnowledgeQueryDef],
      requiredFunctionName: 'respondKnowledgeQuery',
      expectedResponseType: {
        text: false,
        functionCall: true,
      },
    },
    { disableCache: true },
  );

  const functionCall = response.find((part) => part.type === 'functionCall')?.functionCall as
    | FunctionCall<QueryResult>
    | undefined;

  const sourceEntries: KBEntry[] = [];
  for (const id of functionCall?.args?.sourceEntries?.map((e) => e.id) || []) {
    const entry = knowledgeBase.find((e) => e.id === id);
    if (entry) {
      sourceEntries.push(entry);
    }
  }

  return { synthesizedResponse: functionCall?.args?.synthesizedResponse, sourceEntries };
}
